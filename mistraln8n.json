{
  "name": "CSV affiliation -> institution (Mistral self-hosted matcher)",
  "nodes": [
    {
      "parameters": {},
      "id": "ManualTrigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 260]
    },
    {
      "parameters": {
        "filePath": "/data/affiliations.csv"
      },
      "id": "ReadAffiliations",
      "name": "Read Affiliations CSV (binary)",
      "type": "n8n-nodes-base.readBinaryFile",
      "typeVersion": 1,
      "position": [420, 140]
    },
    {
      "parameters": {
        "operation": "toJson",
        "binaryPropertyName": "data",
        "options": {
          "headerRow": true
        }
      },
      "id": "ParseAffiliations",
      "name": "Parse Affiliations CSV",
      "type": "n8n-nodes-base.spreadsheetFile",
      "typeVersion": 1,
      "position": [650, 140]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(i => ({ json: { ...i.json, __src: 'aff' } }));"
      },
      "id": "TagAff",
      "name": "Tag Affiliations",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 140]
    },
    {
      "parameters": {
        "filePath": "/data/institutions.csv"
      },
      "id": "ReadInstitutions",
      "name": "Read Institutions CSV (binary)",
      "type": "n8n-nodes-base.readBinaryFile",
      "typeVersion": 1,
      "position": [420, 380]
    },
    {
      "parameters": {
        "operation": "toJson",
        "binaryPropertyName": "data",
        "options": {
          "headerRow": true
        }
      },
      "id": "ParseInstitutions",
      "name": "Parse Institutions CSV",
      "type": "n8n-nodes-base.spreadsheetFile",
      "typeVersion": 1,
      "position": [650, 380]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(i => ({ json: { ...i.json, __src: 'inst' } }));"
      },
      "id": "TagInst",
      "name": "Tag Institutions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 380]
    },
    {
      "parameters": {
        "mode": "append"
      },
      "id": "AppendBoth",
      "name": "Merge (Append both datasets)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [1120, 260]
    },
    {
      "parameters": {
        "jsCode": "const all = $input.all().map(i => i.json);\n\nconst aff = all.filter(r => r.__src === 'aff');\nconst inst = all.filter(r => r.__src === 'inst');\n\n// CHANGE_ME if your column names differ\nconst AFF_FIELD = 'affiliation';\nconst INST_FIELD = 'institution';\n\nconst instNames = inst\n  .map(r => (r[INST_FIELD] ?? '').toString())\n  .filter(Boolean);\n\nfunction norm(s) {\n  return (s ?? '')\n    .toString()\n    .toLowerCase()\n    .normalize('NFKD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/[^a-z0-9\\s]/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\nfunction score(a, b) {\n  // Cheap heuristic scoring for candidate shortlist\n  const A = norm(a);\n  const B = norm(b);\n  if (!A || !B) return 0;\n  if (A === B) return 1000;\n  let s = 0;\n  if (B.includes(A) || A.includes(B)) s += 50;\n  const aTok = new Set(A.split(' '));\n  const bTok = new Set(B.split(' '));\n  let inter = 0;\n  for (const t of aTok) if (bTok.has(t)) inter++;\n  s += inter * 5;\n  s += Math.min(A.length, B.length) / Math.max(A.length, B.length) * 10;\n  return s;\n}\n\nconst TOP_K = 25;\n\nreturn aff.map(row => {\n  const affiliation = (row[AFF_FIELD] ?? '').toString();\n  const ranked = instNames\n    .map(name => ({ name, s: score(affiliation, name) }))\n    .sort((x, y) => y.s - x.s)\n    .slice(0, TOP_K)\n    .map(x => x.name);\n\n  return {\n    json: {\n      ...row,\n      [AFF_FIELD]: affiliation,\n      __candidates: ranked\n    }\n  };\n});"
      },
      "id": "PrepareJobs",
      "name": "Prepare match jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1360, 260]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://CHANGE_ME_MISTRAL_HOST:8000/v1/chat/completions",
        "sendHeaders": true,
        "headerParametersUi": {
          "parameter": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer CHANGE_ME_TOKEN"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  model: 'CHANGE_ME_MODEL',\n  temperature: 0,\n  messages: [\n    {\n      role: 'system',\n      content: 'You are a data-matching engine. Return ONLY valid JSON, no markdown. Schema: {\"best_institution\": string|null, \"confidence\": number, \"reason\": string}.'\n    },\n    {\n      role: 'user',\n      content:\n        'Affiliation to match: ' + ($json.affiliation ?? '') + '\\n\\n' +\n        'Choose the best match from these candidates (or null if none fit):\\n' +\n        ($json.__candidates ?? []).map((c, i) => `${i+1}. ${c}`).join('\\n')\n    }\n  ]\n} }}"
      },
      "id": "CallMistral",
      "name": "Mistral match (self-hosted)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1600, 260]
    },
    {
      "parameters": {
        "jsCode": "function safeJsonParse(s) {\n  try { return JSON.parse(s); } catch (e) { return null; }\n}\n\nconst resp = $json;\nconst content = resp?.choices?.[0]?.message?.content ?? '';\nconst parsed = safeJsonParse(content);\n\nreturn [\n  {\n    json: {\n      ...$input.item.json,\n      matched_institution: parsed?.best_institution ?? null,\n      match_confidence: parsed?.confidence ?? null,\n      match_reason: parsed?.reason ?? null,\n      // drop candidates from final export to keep CSV clean\n      __candidates: undefined\n    }\n  }\n];"
      },
      "id": "ParseMistral",
      "name": "Parse Mistral response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1840, 260]
    },
    {
      "parameters": {
        "operation": "toFile",
        "fileFormat": "csv",
        "binaryPropertyName": "data",
        "options": {
          "headerRow": true
        }
      },
      "id": "ToCSV",
      "name": "Write result CSV (binary)",
      "type": "n8n-nodes-base.spreadsheetFile",
      "typeVersion": 1,
      "position": [2080, 260]
    },
    {
      "parameters": {
        "fileName": "/data/output_matched.csv",
        "dataPropertyName": "data"
      },
      "id": "WriteFile",
      "name": "Save CSV to disk",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [2320, 260]
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Read Affiliations CSV (binary)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Institutions CSV (binary)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Affiliations CSV (binary)": {
      "main": [
        [
          {
            "node": "Parse Affiliations CSV",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Affiliations CSV": {
      "main": [
        [
          {
            "node": "Tag Affiliations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tag Affiliations": {
      "main": [
        [
          {
            "node": "Merge (Append both datasets)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Institutions CSV (binary)": {
      "main": [
        [
          {
            "node": "Parse Institutions CSV",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Institutions CSV": {
      "main": [
        [
          {
            "node": "Tag Institutions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tag Institutions": {
      "main": [
        [
          {
            "node": "Merge (Append both datasets)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge (Append both datasets)": {
      "main": [
        [
          {
            "node": "Prepare match jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare match jobs": {
      "main": [
        [
          {
            "node": "Mistral match (self-hosted)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mistral match (self-hosted)": {
      "main": [
        [
          {
            "node": "Parse Mistral response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Mistral response": {
      "main": [
        [
          {
            "node": "Write result CSV (binary)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write result CSV (binary)": {
      "main": [
        [
          {
            "node": "Save CSV to disk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {}
}
